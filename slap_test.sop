// Tests for slap CLI parser.
package slap

import (
	"strings"
	"testing"
)

// Command for basic parsing tests
[Command{Name: "greet", About: "Greet command"}]
type GreetTestCmd struct {
	[Arg{Position: 0, Help: "Name argument"}]
	Name string

	[Flag{Short: "c", Long: "count", Default: "1"}]
	Count int

	[Flag{Short: "v", Long: "verbose"}]
	Verbose bool
}

func (cmd GreetTestCmd) Run() error {
	return nil
}

[Subcommands]
type SingleCmd enum {
	Greet GreetTestCmd
}

// Commands for subcommand tests
[Command{Name: "add", About: "Add item"}]
type AddItemCmd struct {
	[Arg{Position: 0}]
	Item string
}

func (cmd AddItemCmd) Run() error {
	return nil
}

[Command{Name: "list", About: "List items"}]
type ListItemsCmd struct {
	[Flag{Short: "a", Long: "all"}]
	All bool
}

func (cmd ListItemsCmd) Run() error {
	return nil
}

[Subcommands]
type MultiCmd enum {
	Add  AddItemCmd
	List ListItemsCmd
}

// Parent with global flags
[Command{Name: "app"}]
type ParentCmd struct {
	[Flag{Short: "v", Long: "verbose", Global: true}]
	Verbose bool
}

// Commands for Hidden/Alias tests
[Command{Name: "create", About: "Create something"}]
type CreateCmd struct {
	[Arg{Position: 0}]
	Name string
}

func (cmd CreateCmd) Run() error {
	return nil
}

[Command{Name: "delete", About: "Delete something"}]
type DeleteCmd struct {
	[Arg{Position: 0}]
	Name string
}

func (cmd DeleteCmd) Run() error {
	return nil
}

[Command{Name: "debug", About: "Debug mode"}]
type DebugCmd struct{}

func (cmd DebugCmd) Run() error {
	return nil
}

[Subcommands]
type AliasCmd enum {
	Create CreateCmd

	[Alias{Name: "rm"}]
	[Alias{Name: "del"}]
	Delete DeleteCmd

	[Hidden]
	Debug DebugCmd
}

func TestParseBasicArg(t *testing.T) {
	sub := ParseArgs[SingleCmd]([]string{"Alice"}) ? err {
		t.Fatalf("unexpected error: %v", err)
	}

	match sub {
	case SingleCmd.Greet(cmd):
		if cmd.Name != "Alice" {
			t.Errorf("expected Name='Alice', got '%s'", cmd.Name)
		}
	}
}

func TestParseFlag(t *testing.T) {
	sub := ParseArgs[SingleCmd]([]string{"-c", "5", "Bob"}) ? err {
		t.Fatalf("unexpected error: %v", err)
	}

	match sub {
	case SingleCmd.Greet(cmd):
		if cmd.Count != 5 {
			t.Errorf("expected Count=5, got %d", cmd.Count)
		}
		if cmd.Name != "Bob" {
			t.Errorf("expected Name='Bob', got '%s'", cmd.Name)
		}
	}
}

func TestParseLongFlag(t *testing.T) {
	sub := ParseArgs[SingleCmd]([]string{"--count", "3", "--verbose", "Charlie"}) ? err {
		t.Fatalf("unexpected error: %v", err)
	}

	match sub {
	case SingleCmd.Greet(cmd):
		if cmd.Count != 3 {
			t.Errorf("expected Count=3, got %d", cmd.Count)
		}
		if !cmd.Verbose {
			t.Error("expected Verbose=true")
		}
	}
}

func TestParseFlagWithEquals(t *testing.T) {
	sub := ParseArgs[SingleCmd]([]string{"--count=7", "Dave"}) ? err {
		t.Fatalf("unexpected error: %v", err)
	}

	match sub {
	case SingleCmd.Greet(cmd):
		if cmd.Count != 7 {
			t.Errorf("expected Count=7, got %d", cmd.Count)
		}
	}
}

func TestParseDefaultValue(t *testing.T) {
	sub := ParseArgs[SingleCmd]([]string{"Eve"}) ? err {
		t.Fatalf("unexpected error: %v", err)
	}

	match sub {
	case SingleCmd.Greet(cmd):
		if cmd.Count != 1 {
			t.Errorf("expected default Count=1, got %d", cmd.Count)
		}
	}
}

func TestParseSubcommandAdd(t *testing.T) {
	sub := ParseArgs[MultiCmd]([]string{"add", "milk"}) ? err {
		t.Fatalf("unexpected error: %v", err)
	}

	match sub {
	case MultiCmd.Add(cmd):
		if cmd.Item != "milk" {
			t.Errorf("expected Item='milk', got '%s'", cmd.Item)
		}
	case MultiCmd.List(cmd):
		t.Error("expected Add variant, got List")
	}
}

func TestParseSubcommandList(t *testing.T) {
	sub := ParseArgs[MultiCmd]([]string{"list", "--all"}) ? err {
		t.Fatalf("unexpected error: %v", err)
	}

	match sub {
	case MultiCmd.Add(cmd):
		t.Error("expected List variant, got Add")
	case MultiCmd.List(cmd):
		if !cmd.All {
			t.Error("expected All=true")
		}
	}
}

func TestParseSubWithParent(t *testing.T) {
	parent, sub := ParseArgsSub[ParentCmd, MultiCmd]([]string{"-v", "add", "eggs"}) ? err {
		t.Fatalf("unexpected error: %v", err)
	}

	if !parent.Verbose {
		t.Error("expected parent Verbose=true")
	}

	match sub {
	case MultiCmd.Add(cmd):
		if cmd.Item != "eggs" {
			t.Errorf("expected Item='eggs', got '%s'", cmd.Item)
		}
	case MultiCmd.List(cmd):
		t.Error("expected Add variant, got List")
	}
}

func TestParseMissingRequired(t *testing.T) {
	_, err := ParseArgs[SingleCmd]([]string{})
	if err == nil {
		t.Error("expected error for missing required argument")
	}

	parseErr, ok := err.(ParseError)
	if !ok {
		t.Fatalf("expected ParseError, got %T", err)
	}

	match parseErr.Kind {
	case ErrorKind.MissingRequired:
		// Expected
	default:
		t.Errorf("expected MissingRequired error, got %v", parseErr.Kind)
	}
}

func TestParseUnknownFlag(t *testing.T) {
	_, err := ParseArgs[SingleCmd]([]string{"--unknown", "Frank"})
	if err == nil {
		t.Error("expected error for unknown flag")
	}

	parseErr, ok := err.(ParseError)
	if !ok {
		t.Fatalf("expected ParseError, got %T", err)
	}

	match parseErr.Kind {
	case ErrorKind.UnknownFlag:
		// Expected
	default:
		t.Errorf("expected UnknownFlag error, got %v", parseErr.Kind)
	}
}

func TestParseMissingSubcommand(t *testing.T) {
	// When no subcommand is provided, help is shown (not an error)
	_, err := ParseArgs[MultiCmd]([]string{})
	if err == nil {
		t.Error("expected help to be shown for missing subcommand")
	}

	parseErr, ok := err.(ParseError)
	if !ok {
		t.Fatalf("expected ParseError, got %T", err)
	}

	match parseErr.Kind {
	case ErrorKind.HelpRequested:
		// Expected - shows help when no subcommand provided
	default:
		t.Errorf("expected HelpRequested, got %v", parseErr.Kind)
	}
}

func TestParseHelpFlag(t *testing.T) {
	_, err := ParseArgs[SingleCmd]([]string{"--help"})
	if err == nil {
		t.Error("expected error for help flag")
	}

	parseErr, ok := err.(ParseError)
	if !ok {
		t.Fatalf("expected ParseError, got %T", err)
	}

	match parseErr.Kind {
	case ErrorKind.HelpRequested:
		// Expected
	default:
		t.Errorf("expected HelpRequested error, got %v", parseErr.Kind)
	}
}

func TestParseInvalidIntValue(t *testing.T) {
	_, err := ParseArgs[SingleCmd]([]string{"--count", "notanumber", "Grace"})
	if err == nil {
		t.Error("expected error for invalid int value")
	}

	parseErr, ok := err.(ParseError)
	if !ok {
		t.Fatalf("expected ParseError, got %T", err)
	}

	match parseErr.Kind {
	case ErrorKind.InvalidValue:
		// Expected
	default:
		t.Errorf("expected InvalidValue error, got %v", parseErr.Kind)
	}
}

// Test parsing with alias
func TestParseAlias(t *testing.T) {
	// "rm" is an alias for "delete"
	sub := ParseArgs[AliasCmd]([]string{"rm", "foo"}) ? err {
		t.Fatalf("unexpected error: %v", err)
	}

	match sub {
	case AliasCmd.Delete(cmd):
		if cmd.Name != "foo" {
			t.Errorf("expected Name='foo', got '%s'", cmd.Name)
		}
	default:
		t.Error("expected Delete variant")
	}
}

// Test parsing with second alias
func TestParseSecondAlias(t *testing.T) {
	// "del" is also an alias for "delete"
	sub := ParseArgs[AliasCmd]([]string{"del", "bar"}) ? err {
		t.Fatalf("unexpected error: %v", err)
	}

	match sub {
	case AliasCmd.Delete(cmd):
		if cmd.Name != "bar" {
			t.Errorf("expected Name='bar', got '%s'", cmd.Name)
		}
	default:
		t.Error("expected Delete variant")
	}
}

// Test parsing with canonical name still works
func TestParseCanonicalName(t *testing.T) {
	sub := ParseArgs[AliasCmd]([]string{"delete", "baz"}) ? err {
		t.Fatalf("unexpected error: %v", err)
	}

	match sub {
	case AliasCmd.Delete(cmd):
		if cmd.Name != "baz" {
			t.Errorf("expected Name='baz', got '%s'", cmd.Name)
		}
	default:
		t.Error("expected Delete variant")
	}
}

// Test hidden subcommand is still usable
func TestParseHiddenSubcommand(t *testing.T) {
	sub := ParseArgs[AliasCmd]([]string{"debug"}) ? err {
		t.Fatalf("unexpected error: %v", err)
	}

	match sub {
	case AliasCmd.Debug(cmd):
		_ = cmd // Debug command parsed successfully
	default:
		t.Error("expected Debug variant")
	}
}

// Test hidden subcommand not in missing subcommand error
func TestHiddenNotInError(t *testing.T) {
	_, err := ParseArgs[AliasCmd]([]string{})
	if err == nil {
		t.Error("expected error for missing subcommand")
	}

	parseErr, ok := err.(ParseError)
	if !ok {
		t.Fatalf("expected ParseError, got %T", err)
	}

	// Error message should not contain "debug"
	if strings.Contains(parseErr.Message, "debug") {
		t.Errorf("hidden subcommand 'debug' should not appear in error message: %s", parseErr.Message)
	}

	// But should contain visible commands
	if !strings.Contains(parseErr.Message, "create") {
		t.Errorf("expected 'create' in error message: %s", parseErr.Message)
	}
	if !strings.Contains(parseErr.Message, "delete") {
		t.Errorf("expected 'delete' in error message: %s", parseErr.Message)
	}
}
